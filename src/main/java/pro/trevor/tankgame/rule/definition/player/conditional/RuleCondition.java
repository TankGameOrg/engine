package pro.trevor.tankgame.rule.definition.player.conditional;

import pro.trevor.tankgame.state.State;
import pro.trevor.tankgame.state.meta.PlayerRef;
import pro.trevor.tankgame.util.Result;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

public class RuleCondition {

    private final IRulePredicate[] predicates;

    public RuleCondition(IRulePredicate... predicates) {
        this.predicates = predicates;
    }

    /**
     * Test all predicates without log entry meta data @see {@link pro.trevor.tankgame.rule.definition.player.conditional.IRulePredicate#test(State, PlayerRef)} for assumptions
     * @param state The game state to test
     * @param player The player to test the condition for
     * @return A result indicating whether any of the predicates failed and why
     */
    public Result<List<String>> test(State state, PlayerRef player) {
        return testPredicates((predicate) -> predicate.test(state, player));
    }

    /**
     * Test all predicates with log entry meta data @see {@link pro.trevor.tankgame.rule.definition.player.conditional.IRulePredicate#test(State, PlayerRef, meta)} for assumptions
     * @param state The game state to test
     * @param player The player to test the condition for
     * @param meta The meta data generated by the log entry
     * @return A result indicating whether any of the predicates failed and why
     */
    public Result<List<String>> test(State state, PlayerRef player, Object... meta) {
        return testPredicates((predicate) -> predicate.test(state, player, meta));
    }

    private Result<List<String>> testPredicates(Function<IRulePredicate, Result<String>> callPredicate) {
        List<String> errors = new ArrayList<>();

        for (IRulePredicate predicate : predicates) {
            Result<String> error = callPredicate.apply(predicate);
            if (error.isError()) {
                errors.add(error.getError());
                break; // Currently a lot of predicates assume that we stop on the first error
            }
        }

        if (errors.isEmpty()) {
            return Result.ok();
        } else {
            return Result.error(errors);
        }
    }
}
